# 智能排课系统约束架构设计

## 概述

智能排课系统的约束架构是一个分层设计，旨在灵活应对各种排课场景的需求。这个架构包括以下几个主要组件：

1. **约束层级定义** (`ConstraintHierarchy`)：定义约束的重要性和优先级层次
2. **基本排课规则** (`BasicSchedulingRules`)：定义通用的、适用于各种排课场景的基本规则
3. **约束定义** (`ConstraintDefinitions`)：定义具体的约束ID和类别
4. **约束管理器** (`ConstraintManager`)：管理约束的状态和应用

## 约束层级结构

约束按重要性和性质分为四个层级：

1. **Level1_CoreHard**：基本排课规则硬约束，如资源冲突、教室容量等基本限制
2. **Level2_ConfigurableHard**：可变硬约束，如教师可用性、教室可用性等可配置的限制
3. **Level3_PhysicalSoft**：物理限制软约束，如教室类型、设备要求等物理资源相关的优化目标
4. **Level4_QualitySoft**：质量软约束，如教师偏好、课表紧凑度等质量提升相关的优化目标

## 组件关系

### 基本排课规则与约束定义的关系

`BasicSchedulingRules` 定义了通用的、高层次的排课规则，这些规则适用于各种排课场景。`ConstraintDefinitions` 则定义了更具体的约束实现。

例如，`BasicSchedulingRules.ResourceConflict`（资源冲突约束）这一通用规则，在 `ConstraintDefinitions` 中对应了多个具体约束：
- `TeacherConflict`：教师同时段冲突约束
- `ClassroomConflict`：教室同时段冲突约束
- `StudentConflict`：学生同时段冲突约束

这种设计使得系统可以在不同层次上理解和处理约束：
- 在通用层面上，我们关注"资源不能冲突"这一抽象规则
- 在具体实现中，我们为每种资源（教师、教室、学生）定义专门的约束

### 约束定义与约束管理器的关系

`ConstraintDefinitions` 定义了约束的ID和分类，而 `ConstraintManager` 负责：
- 维护约束实例的集合
- 管理约束的状态（启用/禁用）
- 设置约束的权重
- 提供按层级或类型查询约束的方法

`ConstraintManager` 不直接依赖于 `ConstraintDefinitions`，而是通过约束的ID建立关联。这种松耦合设计使得约束体系更加灵活，可以在不修改管理器的情况下扩展约束种类。

## 约束在随机算法中的应用

随机算法 (`CPScheduler.GenerateConstraintAwareRandomSolution`) 按层级考虑约束：

1. 首先尝试满足基本排课规则（Level1_CoreHard）
2. 如果失败，尝试考虑可变硬约束（Level2_ConfigurableHard）
3. 如果仍然失败，则使用最小约束集进行强制分配

这种渐进式策略确保在复杂约束下仍能生成可接受的解决方案。

## 约束的应用场景

系统提供了针对不同排课场景的约束集：

1. **大学排课**：侧重于前提课程关系、教师资质和教室类型匹配等约束
2. **中小学排课**：侧重于时间连续性、课程分布均衡和最小间隔等约束
3. **考试排课**：侧重于学生冲突避免、考试间隔和建筑物容量平衡等约束

每种场景都可以通过对应的方法获取推荐约束集。

## 约束的扩展方式

系统支持以下几种约束扩展方式：

1. **添加新的约束定义**：在 `ConstraintDefinitions` 中添加新的约束常量和相应的分组
2. **实现新的约束类**：创建实现 `IConstraint` 接口的新类
3. **向约束管理器注册新约束**：通过 `ConstraintManager.RegisterConstraint` 方法注册新约束

## 总结

这种分层的约束架构设计提供了以下优势：

1. **模块化**：约束定义与约束管理分离，便于独立演化
2. **通用性**：基本规则抽象化，适用于各种排课场景
3. **灵活性**：可以根据需要组合不同约束，满足特定排课需求
4. **可扩展性**：易于添加新约束，不需要修改核心逻辑
5. **渐进式解算**：在复杂约束下仍能提供可接受的解决方案 